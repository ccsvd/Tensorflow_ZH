# 类 `tensorflow::Env` <a class="md-anchor" id="AUTOGENERATED-class--tensorflow--env-"></a>

tensorflow实现用于获取操作系统的功能的接口，比如文件系统等。

调用者可以通过Env提供细粒度的控制

所有的Env实现在多线程的并发处理中均是线程安全的且不需要借助外部的同步机制。

##成员函数 <a class="md-anchor" id="AUTOGENERATED-member-summary"></a>


###Member Details

#### `tensorflow::Env::Env()` {#tensorflow_Env_Env}





#### `virtual tensorflow::Env::~Env()=default` {#virtual_tensorflow_Env_Env}





#### `Status tensorflow::Env::GetFileSystemForFile(const string &fname, FileSystem **result)` {#Status_tensorflow_Env_GetFileSystemForFile}

根据文件名fname返回一个FileSystem的对象，用于操作文件。这个FileSystem作为一个实例被用于接下来的非虚拟函数中相关的文件系统。

FileSystem的对象仍然属于Env对象，并且当“环境”被销毁的时候（有可能）被销毁。


#### `Status tensorflow::Env::GetRegisteredFileSystemSchemes(std::vector< string > *schemes)` {#Status_tensorflow_Env_GetRegisteredFileSystemSchemes}

返回当前“环境"(Env)中注册的文件系统“格式”


#### `Status tensorflow::Env::RegisterFileSystem(const string &scheme, FileSystemRegistry::Factory factory)` {#Status_tensorflow_Env_RegisterFileSystem}





#### `Status tensorflow::Env::NewRandomAccessFile(const string &fname, std::unique_ptr< RandomAccessFile > *result)` {#Status_tensorflow_Env_NewRandomAccessFile}

根据文件名fname，创建一个崭新的任意存储的只读文件（注：可能类似于Java中的RandomAccessFile，可以直接随意的定位到文件的位置进行文件读取等操作）

如果成功将新文件指针存入到 *result中并返回OK。如果失败将 *result设为NULL，返回 non-OK。加入文件不存在返回状态non-OK。

返回的文件可能被多个线程同时获取。

返回的RandomAccessFile的所有权被赋予调用者，当不使用的时候应当被删除。且文件对象不应该比Env“存活”的时间长。

#### `Status tensorflow::Env::NewWritableFile(const string &fname, std::unique_ptr< WritableFile > *result)` {#Status_tensorflow_Env_NewWritableFile}

根据文件名fname创建一个可以写入的新文件。

如果存在同名文件则删除并创建新的文件。创建成功，将新文件的指针赋予 *result并返回OK。失败， *result置为NULL，并返回non-OK。

返回的文件同时只能被一个线程拥有。

WritableFile的所有权赋予调用者，并且在不使用的时候进行删除。同时对象不应该比Env“存活”的时间长。

#### `Status tensorflow::Env::NewAppendableFile(const string &fname, std::unique_ptr< WritableFile > *result)` {#Status_tensorflow_Env_NewAppendableFile}

创建一个对象附加到一个存在的文件或者创建一个写入的新文件（如果文件fname不存在）。

如果成功，将新文件指针赋予*result并返回OK，失败，将 *result设为NULL返回non-OK。

返回的文件同时只能一个线程持有。

返回的WritableFile对象的所有权赋予调用者，当不使用的时候应当删除。且，“存活”时间应小于Env对象。
#### `Status tensorflow::Env::NewReadOnlyMemoryRegionFromFile(const string &fname, std::unique_ptr< ReadOnlyMemoryRegion > *result)` {#Status_tensorflow_Env_NewReadOnlyMemoryRegionFromFile}

创建一个只读的内存区域，内容为fname对应的文件内容。

如果成功，将只读内存填入fname文件对应的内容，并返回对应的指针。内存区域的所有权赋予调用者。如果失败将*result设为NULL，并返回non-OK。

返回的内存区域同时可以被多个并行的线程持有。

ReadOnlyMemoryRegion对象的所有权赋予调用者，当不使用的是应当被删除。内存区域对象的存活时间应小于Env对象。
#### `bool tensorflow::Env::FileExists(const string &fname)` {#bool_tensorflow_Env_FileExists}

如果文件fname存在返回true



#### `Status tensorflow::Env::GetChildren(const string &dir, std::vector< string > *result)` {#Status_tensorflow_Env_GetChildren}

将目录dir下的子目录的名字存储到*result中。名字为目录

*result的原始内容被抛弃。

#### `Status tensorflow::Env::DeleteFile(const string &fname)` {#Status_tensorflow_Env_DeleteFile}

删除文件fname


#### `Status tensorflow::Env::DeleteRecursively(const string &dirname, int64 *undeleted_files, int64 *undeleted_dirs)` {#Status_tensorflow_Env_DeleteRecursively}

删除目录dirname下的所有目录和文件。undeleted_files下的文件 和 undeleted_dirs下的目录将不被删除（不返回OK表示上诉属性未指明）。
要求：undeleted_files 和 undeleted_dirs不为空
返回值：
OK - 目录存在且可以删除目录下的所有文件

NOT_FOUND - 目录不存在
PERMISSION_DENIED - 目录或者其子目录（文件）不可写。
UNIMPLEMENTED - 一些"子方法'（比如Delete）没有被实现
#### `Status tensorflow::Env::CreateDir(const string &dirname)` {#Status_tensorflow_Env_CreateDir}

创建一个名为dirname的目录

#### `Status tensorflow::Env::DeleteDir(const string &dirname)` {#Status_tensorflow_Env_DeleteDir}

删除目录dirname


#### `Status tensorflow::Env::Stat(const string &fname, FileStatistics *stat)` {#Status_tensorflow_Env_Stat}

获得给定路径的统计数据



#### `Status tensorflow::Env::IsDirectory(const string &fname)` {#Status_tensorflow_Env_IsDirectory}


返回给定的路径是否为目录。一般的返回代码如下（不包括全部返回代码）：

OK - 路径存在且是一个目录。

FAILED_PRECONDITION - 路径存在但不是目录

NOT_FOUND - 路径不存在

PERMISSION_DENIED - 没有足够权限

UNIMPLEMENTED - 文件工厂不支持目录

#### `Status tensorflow::Env::GetFileSize(const string &fname, uint64 *file_size)` {#Status_tensorflow_Env_GetFileSize}

将文件fname的大小存入到file_size中


#### `Status tensorflow::Env::RenameFile(const string &src, const string &target)` {#Status_tensorflow_Env_RenameFile}

将src文件命名为target，如果target存在将会被替代。


#### `virtual uint64 tensorflow::Env::NowMicros()=0` {#virtual_uint64_tensorflow_Env_NowMicros}

返回从固定时间点到现在的毫秒。只能用来计算时间差。


#### `virtual uint64 tensorflow::Env::NowSeconds()` {#virtual_uint64_tensorflow_Env_NowSeconds}

返回从固定时间点的秒数。只能用来计算时间差。


#### `virtual void tensorflow::Env::SleepForMicroseconds(int64 micros)=0` {#virtual_void_tensorflow_Env_SleepForMicroseconds}

是线程睡眠/延迟给定的毫秒数。


#### `virtual Thread* tensorflow::Env::StartThread(const ThreadOptions &thread_options, const string &name, std::function< void()> fn) TF_MUST_USE_RESULT=0` {#virtual_Thread_tensorflow_Env_StartThread}


返回一个新的线程且正在执行fn()函数，同时这个线程命名为"name"（用于调试和性能分析）。

调用者拥有返回结果的控制权，并且最终要删除（删除操作将被阻塞，知道fn()执行完）。

#### `virtual void tensorflow::Env::SchedClosure(std::function< void()> closure)=0` {#virtual_void_tensorflow_Env_SchedClosure}

将closure安排到线程池中（closure可能为“块”）。



#### `virtual void tensorflow::Env::SchedClosureAfter(int64 micros, std::function< void()> closure)=0` {#virtual_void_tensorflow_Env_SchedClosureAfter}

经过给定的micros毫秒，将closure放入到线程池中（closure可能为“块”）。



#### `virtual Status tensorflow::Env::LoadLibrary(const char *library_filename, void **handle)=0` {#virtual_Status_tensorflow_Env_LoadLibrary}

加载一个的动态库。

传入的动态库文件"library_filename"应该动态的针对特定平台进行加载。

应当根据特定的平台决定加载库文件的路径，且此文档并不提供（决策方法）。

如果成功，将库文件的“句柄”赋予*handle并且返回OK

否则将*handle设为nullptrt，返回一个错误状态。

#### `virtual Status tensorflow::Env::GetSymbolFromLibrary(void *handle, const char *symbol_name, void **symbol)=0` {#virtual_Status_tensorflow_Env_GetSymbolFromLibrary}

从动态的库中得到“标志”的指针。

“handle”是从前一个函数得到的库文件句柄。

如果成功，将“标志”的指针赋予"*symbol"，并返回OK。

否则"*symbol"设为nullptr，并返回错误代码。

#### `static Env* tensorflow::Env::Default()` {#static_Env_tensorflow_Env_Default}

针对当前系统返回一个默认的“环境”。

有经验的用户可以提供自己的环境“Env”代替当前的默认方法。

Default（）的结果输入当前“库”且不允许删除
